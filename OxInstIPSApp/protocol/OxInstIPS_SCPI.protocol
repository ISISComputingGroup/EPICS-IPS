# File OxInstIPS_SCPI.protocol
#
# Stream Device protocol file for the Oxford Instruments Modular IPS 
# superconducting magnet power supplies.
# This protocol supports the SCPI commands for the IPS, replacing the legacy command set.
#
# The full protocol is described in the IPS Operators Handbook. 
#
# The commands are case-sensitive.
# Keywords are a maximum of four characters long. Keywords longer than four characters
# generate an invalid command response.
# Keywords are separated by a colon: (ASCII 0x3Ah).
# The maximum line length is 1024 bytes (characters), including line terminators.
# All command lines are terminated by the new line character \n (ASCII 0x0Ah).
#
Terminator = "\n";

# The lagacy timeout values cribbed from OxInstCryojet module - had occasional
# problems with the default settings with one record timing out and
# another record seeing the reply - see if longer time out will fix it.
# Also see if this is still applicable to the SCPI protocol.
#
readtimeout = 500;
replytimeout = 5000;
locktimeout = 20000;
PollPeriod = 500;
ExtraInput = Ignore;

# Device board/slot names
magnet_temperature_sensor = "MB1.T1";
level_meter = "DB1.L1";
magnet_supply = "GRPZ";
temperature_sensor_10T = "DB8.T1";
pressure_sensor_10T = "DB5.P1";

#########################################################################################
# ---------
# *IDN?
# ---------
# IDN:OXFORD INSTRUMENTS:MERCURY dd:ss:ff
# Where:
#   dd is the basic instrument type (iPS , iPS, Cryojet etc.)
#   ss is the serial number of the main board
#   ff is the firmware version of the instrument
# Get the unit version information - returns unit type and firmware information.
# Manual says letter commands always reply with themselves at the start, but
# found out this one does not.  Manual also shows a copyright symbol, which is not an
# ASCII symbol and might cause problems for EPICS.  In practice found (c) instead.
# The %s format grabs the string upto the first space, the %c grabs the rest.  It
# was too long to fit into one EPICS string record value.
getVersion { out "*IDN?"; wait 100;
             in "IDN:OXFORD INSTRUMENTS:%(\$1MODEL.VAL)[ a-zA-Z0-9]:%*[ a-zA-Z0-9]:%(\$1VERSION.VAL)s"; wait 100;}

#########################################################################################

# Get measured power supply voltage in volts
# The return string is of the form: STAT:DEV:GRPZ:PSU:SIG:VOLT:-0.0002V
getSupplyVoltage { out "READ:DEV:" $magnet_supply ":PSU:SIG:VOLT"; wait 100;
                   in "STAT:DEV:" $magnet_supply ":PSU:SIG:VOLT:%f%*s"; wait 100;}

# Get demand current (output current) in amps. We are only interested in the Z axis magnet group.
# The return string is of the form: STAT:DEV:GRPZ:PSU:CSET:<value>:A
getDemandCurrent { out "READ:DEV:" $magnet_supply ":PSU:SIG:CSET"; wait 100;
                   in "STAT:DEV:" $magnet_supply ":PSU:SIG:CSET:%f%*s"; wait 100;}

# Get measured magnet curren in amps - ER=no.
# The return string is of the form: STAT:DEV:GRPZ:PSU:SIG:CURR:-0.0001A
getMeasuredMagnetCurrent { out "READ:DEV:" $magnet_supply ":PSU:SIG:CURR"; wait 100;
                           in "STAT:DEV:" $magnet_supply ":PSU:SIG:CURR:%f%*s"; wait 100;}

# Get set point (target current) in amps ER=yes.
getSetpointCurrent { out "READ:DEV:" $magnet_supply ":PSU:SIG:CSET"; wait 100;
                     in "STAT:DEV:" $magnet_supply ":PSU:SIG:CSET:%f%*s"; wait 100;}

# Get current sweep rate in amps per minute ER=yes.
getCurrentSweepRate { out "READ:DEV:" $magnet_supply ":PSU:SIG:RCST"; wait 100;
                      in "STAT:DEV:" $magnet_supply ":PSU:SIG:RCST:%f%*s"; wait 100;}

# Get demand field (output field) in tesla ER=yes.
getDemandField { out "READ:DEV:" $magnet_supply ":PSU:SIG:FLD"; wait 100;
                 in "STAT:DEV:" $magnet_supply ":PSU:SIG:FLD:%f%*s"; wait 100;}

# Get set point (target field) in tesla ER=yes.
getSetpointField { out "READ:DEV:" $magnet_supply ":PSU:SIG:FSET"; wait 100;
                   in "STAT:DEV:" $magnet_supply ":PSU:SIG:FSET:%f%*s"; wait 100;}

# Get field sweep rate in tesla per minute ER=yes.
# Returns status like: STAT:DEV:GRPZ:PSU:SIG:RFST:0.3850T/m
getFieldSweepRate { out "READ:DEV:" $magnet_supply ":PSU:SIG:RFST"; wait 100;
                    in "STAT:DEV:" $magnet_supply ":PSU:SIG:RFST:%f%*s"; wait 100;}

# Get software voltage limit in volts ER=no.
# The documentation states that a float is returned, but in reality, a string may be returned instead, such as 'N/A'
getSoftwareVoltageLimit { out "READ:DEV:" $magnet_supply ":PSU:VLIM"; wait 100;
                          in "STAT:DEV:" $magnet_supply ":PSU:VLIM:%f%*s";  @mismatch{in "%*s";} wait 100;}

# Get persistent magnet current in amps ER=yes.
getPersistentMagnetCurrent { out "READ:DEV:" $magnet_supply ":PSU:SIG:PCUR"; wait 100;
                             in "STAT:DEV:" $magnet_supply ":PSU:SIG:PCUR:%f%*s"; wait 100;}

# Get persistent magnetic field in tesla ER=yes.
getPersistentMagnetField { out "READ:DEV:" $magnet_supply ":PSU:SIG:PFLD"; wait 100;
                           in "STAT:DEV:" $magnet_supply ":PSU:SIG:PFLD:%f%*s"; wait 100;}

# Get switch heater current in milliamp ER=no.
getHeaterCurrent { out "READ:DEV:" $magnet_supply ":PSU:SHTC"; wait 100;
                   in "STAT:DEV:" $magnet_supply ":PSU:SHTC:%f%*s"; wait 100;}

# Get safe current limit, most negative in amps ER=no.
getNegCurrentLimit { out "READ:DEV:" $magnet_supply ":PSU:CLIM"; wait 100;
                     in "STAT:DEV:" $magnet_supply ":PSU:CLIM:%f%*s"; wait 100;}

# Get safe current limit, most positive in amps ER=no.
# no units appended to the value, so assume amps.
getPosCurrentLimit { out "READ:DEV:" $magnet_supply ":PSU:CLIM"; wait 100;
                     in "STAT:DEV:" $magnet_supply ":PSU:CLIM:%f"; wait 100;}

# Get lead resistance (PTC/NTC) Ohms.
# unit appended 'R'
getLeadResistance { out "READ:DEV:" $magnet_temperature_sensor ":TEMP:SIG:RES"; wait 100;
                    in "STAT:DEV:" $magnet_temperature_sensor ":TEMP:SIG:RES:%f%*s"; wait 100;}

# Get magnet inductance in henry ER=no.
# no units appended
getMagnetInductance { out "READ:DEV:" $magnet_supply ":PSU:IND"; wait 100;
                      in "STAT:DEV:" $magnet_supply ":PSU:IND:%f"; wait 100;}

# Get Activity status (analogous to the legacy A command)
getActivity { out "READ:DEV:" $magnet_supply ":PSU:ACTN"; wait 100;
              in "STAT:DEV:" $magnet_supply ":PSU:ACTN:%#{HOLD=0|RTOS=1|RTOZ=2|CLMP=4}"; wait 100;}

getHeaterStatus { out "READ:DEV:" $magnet_supply ":PSU:SIG:SWHT"; wait 100;
                  in "STAT:DEV:" $magnet_supply ":PSU:SIG:SWHT:%{OFF|ON}"; wait 100;}

# *** Need to know what is returned on no alarms present, as it is not documented. ***
getSysAlarms { out "READ:SYS:ALRM"; wait 100;}

# The following two reads are used to read the system alarms, hopefully in any format or order,
# as long as the essential patterns match somewhere in the input string.
readSysAlarmsTemperatureBoard {
    extrainput = ignore;
    in "%*/MB1.T1\t/%#{Open Circuit=1|Short Circuit=2|Calibration Error=3|Firmware Error=4|Board Not Configured=5};";}
readSysAlarmsLevelMeterBoard {
    extrainput = ignore;
    in "%*/DB1.L1\t/%#{Open Circuit=1|Short Circuit=2|ADC Error=3|Over Demand=4|Over Temperature=5|Firmware Error=6|Board Not Configured=7|No Reserve=8};";}

# --------------- The following work around limitation of getting legacy status from SCPI protocol -------------
# Get PSU Status status DWORD
getMagnetSupplyStatus { out "READ:DEV:" $magnet_supply ":PSU:STAT"; wait 100;
                        in "STAT:DEV:" $magnet_supply ":PSU:STAT:%x"; wait 100;}

# --------------------------------------------------------------------------------------------------------------


# ---------
# SYS:LOCK Command
# ---------
# Set Control mode - grab control of the unit from local users.
# OFF | SOFT | ON
# With a real device, this command always replies: STAT:SET:SYS:LOCK:OFF:DENIED
# where 'OFF' may be 'OFF', 'ON' or 'SOFT'.
# It's also not possible to read the LOCK status. So this feature might be totally useless.
setControl { out "SET:SYS:LOCK:%{OFF|SOFT|ON}"; in "READ:SYS:LOCK:%*s";}

# ---------
# DEV:<UID>:PSU:ACTN
# ---------
# Set the activity - i.e. Make it do something.
# HOLD -> Hold
# RTOS -> To Set Point
# RTOZ -> To Zero
# CLMP -> Clamp
setActivity { out "SET:DEV:" $magnet_supply ":PSU:ACTN:%#{HOLD=0|RTOS=1|RTOZ=2|CLMP=4}"; wait 100;
              in "STAT:SET:DEV:" $magnet_supply ":PSU:ACTN:%*s"; wait 100;}

# ---------
# SWHT Command
# ---------
#
# Set the status of the heater.
# 0 = heater off (close switch)
# 1 = heater on (open switch) [Checks that magnet curr == psu curr before having any effect, so safer]
# Returns status of this form: STAT:SET:DEV:GRPZ:PSU:SIG:SWHT:OFF:VALID
# DO NOT USE SWHN command!!
#
setHeaterStatus { out "SET:DEV:" $magnet_supply ":PSU:SIG:SWHT:%#{OFF=0|ON=1}"; wait 100;
                  in "STAT:SET:DEV:" $magnet_supply ":PSU:SIG:SWHT:%*s"; wait 100;}

# Set the setpoint (target) current.
# Returns status like: STAT:SET:DEV:GRPZ:PSU:SIG:CSET:0.0004:VALID
setSetpointCurrent { out "SET:DEV:" $magnet_supply ":PSU:SIG:CSET:%#.4f"; wait 100;
                     in "STAT:SET:DEV:" $magnet_supply ":PSU:SIG:CSET:%*f:%*s"}

# Set the setpoint (target) field.
# Returns status like: STAT:SET:DEV:GRPZ:PSU:SIG:FSET:0.00:VALID
setSetpointField { out "SET:DEV:" $magnet_supply ":PSU:SIG:FSET:%#.5f"; wait 100;
                   in "STAT:SET:DEV:" $magnet_supply ":PSU:SIG:FSET:%*f%*s"}

# Set current sweep rate.
# Rate at which current will be ramped or swept to target, either the setpoint or zero.
# Returns status like: STAT:DEV:GRPZ:PSU:SIG:RCST:5.5:VALID
setCurrentSweepRate { out "SET:DEV:" $magnet_supply ":PSU:SIG:RCST:%#.3f"; wait 100;
                      in "STAT:SET:DEV:" $magnet_supply ":PSU:SIG:RCST:%*f%*s"}

# Set field sweep rate.
# Rate at which field will be ramped or swept to target, either the setpoint or zero.
# Returns status like: STAT:SET:DEV:GRPZ:PSU:SIG:RFST:0.3850:VALID
setFieldSweepRate { out "SET:DEV:" $magnet_supply ":PSU:SIG:RFST:%#.4f"; wait 100;
                    in "STAT:SET:DEV:" $magnet_supply ":PSU:SIG:RFST:%*f%*s"}

# -------------------------------------------------------
#    LEVELS BOARD COMMANDS
# -------------------------------------------------------
getLevelNitFreqZero { out "READ:DEV:" $level_meter ":LVL:NIT:FREQ:ZERO"; wait 100;
                  in  "STAT:DEV:" $level_meter ":LVL:NIT:FREQ:ZERO:%f"; wait 100;}
setLevelNitFreqZero { out "SET:DEV:" $level_meter ":LVL:NIT:FREQ:ZERO"; wait 100;
                  in  "STAT:SET:DEV:" $level_meter ":LVL:NIT:FREQ:ZERO:%*f"; wait 100;}
getLevelNitFreqFull { out "READ:DEV:" $level_meter ":LVL:NIT:FREQ:FULL"; wait 100;
                  in  "STAT:DEV:" $level_meter ":LVL:NIT:FREQ:FULL:%f"; wait 100;}
setLevelNitFreqFull { out "SET:DEV:" $level_meter ":LVL:NIT:FREQ:FULL"; wait 100;
                  in  "STAT:SET:DEV:" $level_meter ":LVL:NIT:FREQ:FULL:%*f"; wait 100;}
getLevelHeEmptyRes { out "READ:DEV:" $level_meter ":LVL:HEL:RES:ZERO"; wait 100;
                     in  "STAT:DEV:" $level_meter ":LVL:HEL:RES:ZERO:%f"; wait 100;}
setLevelHeEmptyRes { out "SET:DEV:" $level_meter ":LVL:HEL:RES:ZERO:%f"; wait 100;
                     in  "STAT:SET:DEV:" $level_meter ":LVL:HEL:RES:ZERO:%*f%*s"; wait 100;}
getLevelHeFullRes { out "READ:DEV:" $level_meter ":LVL:HEL:RES:FULL"; wait 100;
                     in  "STAT:DEV:" $level_meter ":LVL:HEL:RES:FULL:%f"; wait 100;}
setLevelHeFullRes { out "SET:DEV:" $level_meter ":LVL:HEL:RES:FULL:%f"; wait 100;
                     in  "STAT:SET:DEV:" $level_meter ":LVL:HEL:RES:FULL:%*f%*s"; wait 100;}


